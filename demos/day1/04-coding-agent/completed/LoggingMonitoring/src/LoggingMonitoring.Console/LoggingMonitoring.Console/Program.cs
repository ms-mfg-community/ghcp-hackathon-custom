using System.Text.Json;
using LoggingMonitoring.Core.Logging;
using LoggingMonitoring.Core.Logging.Providers;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace LoggingMonitoring.Console;

/// <summary>
/// Day 1.4 Demo: GitHub Copilot Coding Agent - Multi-Step Problem Solving
/// Demonstrates how agents decompose and solve complex problems.
/// 
/// This is a .NET 9.0 port of the Python logging and monitoring system,
/// showcasing comprehensive logging with multiple output channels,
/// error tracking, and performance metrics.
/// </summary>
class Program
{
    static void Main(string[] args)
    {
        System.Console.WriteLine("======================================================================");
        System.Console.WriteLine("GitHub Copilot Coding Agent - Complex System Demonstration (.NET 9.0)");
        System.Console.WriteLine("======================================================================");
        System.Console.WriteLine();
        System.Console.WriteLine("This system was generated by a Copilot Agent when asked to:");
        System.Console.WriteLine("'Build a comprehensive logging and monitoring system'");
        System.Console.WriteLine();

        // Setup dependency injection
        var services = new ServiceCollection();

        // Register services as singletons
        services.AddSingleton<IErrorTracker, ErrorTracker>();
        services.AddSingleton<IMetricsCollector, MetricsCollector>();

        // Build service provider
        var serviceProvider = services.BuildServiceProvider();

        // Get services
        var errorTracker = serviceProvider.GetRequiredService<IErrorTracker>();
        var metricsCollector = serviceProvider.GetRequiredService<IMetricsCollector>();

        // Create logger factory and configure providers
        var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.ClearProviders();
            builder.AddProvider(new ColoredConsoleLoggerProvider());
            builder.AddProvider(new JsonFileLoggerProvider("demo.log"));
            builder.AddProvider(new MetricsLoggerProvider(metricsCollector));
            builder.SetMinimumLevel(LogLevel.Debug);
        });

        var logger = loggerFactory.CreateLogger<Program>();

        // Initialize system
        logger.LogInformation("Initializing logging and monitoring system");

        // Run workload simulation
        SimulateApplicationWorkload(logger, errorTracker, metricsCollector);

        // Flush all buffered logs
        FlushAllProviders(loggerFactory);

        // Generate and display report
        System.Console.WriteLine();
        System.Console.WriteLine("======================================================================");
        System.Console.WriteLine("SYSTEM REPORT");
        System.Console.WriteLine("======================================================================");

        var report = new Dictionary<string, object>
        {
            ["timestamp"] = DateTime.Now.ToString("O"),
            ["metrics_summary"] = metricsCollector.GetSummary(),
            ["error_summary"] = errorTracker.GetErrorSummary()
        };

        var jsonOptions = new JsonSerializerOptions { WriteIndented = true };
        System.Console.WriteLine(JsonSerializer.Serialize(report, jsonOptions));

        System.Console.WriteLine();
        System.Console.WriteLine("======================================================================");
        System.Console.WriteLine("Demonstration Complete!");
        System.Console.WriteLine("======================================================================");

        // Cleanup
        loggerFactory.Dispose();
    }

    /// <summary>
    /// Simulates typical application workload with various operations.
    /// </summary>
    static void SimulateApplicationWorkload(
        ILogger logger,
        IErrorTracker errorTracker,
        IMetricsCollector metricsCollector)
    {
        logger.LogInformation("Starting workload simulation");

        // Successful data processing operations
        logger.TrackOperation(
            "DataProcessor",
            "process_data_small",
            metricsCollector,
            errorTracker,
            () => ProcessData(1000));

        logger.TrackOperation(
            "DataProcessor",
            "process_data_large",
            metricsCollector,
            errorTracker,
            () => ProcessData(5000));

        // Validation operations
        logger.LogDebug("Validating inputs");

        try
        {
            logger.TrackOperation(
                "Validator",
                "validate_input",
                metricsCollector,
                errorTracker,
                () => ValidateInput("test_data"));
        }
        catch (ArgumentException)
        {
            // Expected failure - already logged
        }

        // Error scenario - empty input
        try
        {
            logger.TrackOperation(
                "Validator",
                "validate_input",
                metricsCollector,
                errorTracker,
                () => ValidateInput(""));
        }
        catch (ArgumentException)
        {
            // Expected failure - already logged
        }

        logger.LogInformation("Workload simulation complete");
    }

    /// <summary>
    /// Simulates data processing with variable duration.
    /// </summary>
    /// <param name="dataSize">The size of data to process.</param>
    /// <returns>A message indicating processing completion.</returns>
    static string ProcessData(int dataSize)
    {
        // Simulate processing time proportional to data size
        Thread.Sleep((int)(100 * (dataSize / 1000.0)));
        return $"Processed {dataSize} items";
    }

    /// <summary>
    /// Simulates input validation that may throw exceptions.
    /// </summary>
    /// <param name="input">The input string to validate.</param>
    /// <returns>The length of the valid input.</returns>
    /// <exception cref="ArgumentException">Thrown when input is empty.</exception>
    static int ValidateInput(string input)
    {
        if (string.IsNullOrEmpty(input))
            throw new ArgumentException("Empty input");

        return input.Length;
    }

    /// <summary>
    /// Flushes all buffered logs from file providers.
    /// </summary>
    static void FlushAllProviders(ILoggerFactory loggerFactory)
    {
        // Note: In a production system, you would maintain references to providers
        // Here we're demonstrating the concept - the JsonFileLoggerProvider
        // will flush on dispose when the factory is disposed
    }
}
