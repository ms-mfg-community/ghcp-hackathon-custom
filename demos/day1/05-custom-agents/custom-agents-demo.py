"""
Day 1.5 Demo: Custom GitHub Copilot Agent Modes
Demonstrates custom agents for specific domains: DevOps, Database, and Security.

This module simulates the types of code and patterns that custom agents
generate for domain-specific tasks.
"""

from dataclasses import dataclass
from typing import Dict, List, Optional
from enum import Enum
import json


# ============================================================================
# DEVOPS AGENT MODE - Infrastructure as Code Generation
# ============================================================================

class CloudProvider(Enum):
    AZURE = "azure"
    AWS = "aws"
    GCP = "gcp"


class AppServiceTier(Enum):
    FREE = "F1"
    SHARED = "D1"
    BASIC = "B1"
    STANDARD = "S1"
    PREMIUM = "P1"


@dataclass
class AppServiceConfig:
    """Configuration for cloud app service (generated by DevOps Agent)"""
    name: str
    resource_group: str
    region: str
    tier: AppServiceTier
    instance_count: int
    runtime: str
    startup_script: Optional[str] = None
    
    def to_terraform(self) -> str:
        """Convert to Terraform configuration"""
        return f"""
# Generated by DevOps Agent Mode
resource "azurerm_app_service" "{self.name}" {{
  name                = "{self.name}"
  location            = "{self.region}"
  resource_group_name = "{self.resource_group}"
  app_service_plan_id = azurerm_app_service_plan.{self.name}_plan.id

  site_config {{
    dotnet_framework_version = "{self.runtime}"
    scm_type                = "LocalGit"
  }}

  app_settings = {{
    "WEBSITE_NODE_DEFAULT_VERSION" = "14.15.0"
  }}
}}

resource "azurerm_app_service_plan" "{self.name}_plan" {{
  name                = "{self.name}-plan"
  location            = "{self.region}"
  resource_group_name = "{self.resource_group}"
  kind                = "Linux"

  sku {{
    tier = "{self.tier.value[0]}"
    size = "{self.tier.value}"
  }}
}}
"""


class DevOpsAgent:
    """Custom DevOps Agent Mode for infrastructure code generation"""
    
    @staticmethod
    def generate_ci_cd_pipeline(project_name: str, language: str) -> Dict:
        """Generate CI/CD pipeline configuration"""
        
        if language.lower() == "dotnet":
            pipeline = {
                "trigger": ["main", "develop"],
                "pool": {
                    "vmImage": "ubuntu-latest"
                },
                "stages": [
                    {
                        "stage": "Build",
                        "jobs": [
                            {
                                "job": "BuildJob",
                                "steps": [
                                    {"task": "UseDotNet@2", "inputs": {"version": "6.0.x"}},
                                    {"script": "dotnet restore"},
                                    {"script": "dotnet build --configuration Release"},
                                    {"script": "dotnet test --configuration Release"}
                                ]
                            }
                        ]
                    },
                    {
                        "stage": "Deploy",
                        "dependsOn": "Build",
                        "condition": "succeeded()",
                        "jobs": [
                            {
                                "job": "DeployJob",
                                "steps": [
                                    {"script": "dotnet publish -c Release -o ./publish"},
                                    {"task": "PublishBuildArtifacts@1"}
                                ]
                            }
                        ]
                    }
                ]
            }
        else:
            pipeline = {"error": f"Unsupported language: {language}"}
        
        return pipeline
    
    @staticmethod
    def generate_docker_config(app_name: str, runtime: str) -> str:
        """Generate Docker configuration"""
        
        if runtime == "dotnet":
            dockerfile = f"""
FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build
WORKDIR /src
COPY ["{app_name}.csproj", "."]
RUN dotnet restore

FROM build AS publish
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY --from=publish /app/publish .
EXPOSE 80
ENTRYPOINT ["dotnet", "{app_name}.dll"]
"""
        else:
            dockerfile = "# Unsupported runtime"
        
        return dockerfile


# ============================================================================
# DATABASE AGENT MODE - Query Optimization and Schema Design
# ============================================================================

@dataclass
class QueryOptimization:
    """Database query optimization (generated by Database Agent)"""
    original_query: str
    optimized_query: str
    expected_improvement: str
    rationale: str


class DatabaseAgent:
    """Custom Database Agent Mode for query optimization and schema design"""
    
    @staticmethod
    def analyze_and_optimize_query(query: str) -> QueryOptimization:
        """Analyze SQL query and provide optimization"""
        
        # Example optimization for a common pattern
        if "SELECT *" in query and "JOIN" in query:
            optimization = QueryOptimization(
                original_query=query,
                optimized_query=query.replace("SELECT *", 
                    "SELECT u.id, u.name, o.order_id, o.amount"),
                expected_improvement="20-30% faster - reduces data transfer",
                rationale="Selecting specific columns instead of * reduces I/O. "
                         "Use only required columns."
            )
        else:
            optimization = QueryOptimization(
                original_query=query,
                optimized_query=query,
                expected_improvement="No optimization found",
                rationale="Query follows optimization best practices."
            )
        
        return optimization
    
    @staticmethod
    def design_normalized_schema(entities: Dict[str, List[str]]) -> str:
        """Design normalized database schema"""
        
        schema = "-- Normalized Database Schema\n\n"
        
        for entity, fields in entities.items():
            schema += f"CREATE TABLE {entity} (\n"
            schema += f"    id INT PRIMARY KEY IDENTITY(1,1),\n"
            
            for field in fields:
                schema += f"    {field} NVARCHAR(MAX) NOT NULL,\n"
            
            schema += f"    created_at DATETIME DEFAULT GETDATE(),\n"
            schema += f"    updated_at DATETIME DEFAULT GETDATE()\n"
            schema += ");\n\n"
        
        return schema
    
    @staticmethod
    def generate_indexes(table_name: str, columns: List[str]) -> str:
        """Generate index creation statements"""
        
        indexes = f"-- Indexes for {table_name}\n\n"
        
        for i, col in enumerate(columns):
            index_name = f"idx_{table_name}_{col}"
            indexes += f"CREATE INDEX {index_name} ON {table_name}({col});\n"
        
        # Composite index
        if len(columns) > 1:
            comp_cols = ", ".join(columns[:2])
            indexes += f"\nCREATE COMPOSITE INDEX " \
                      f"idx_{table_name}_composite ON {table_name}({comp_cols});\n"
        
        return indexes


# ============================================================================
# SECURITY AGENT MODE - Vulnerability Analysis and Compliance
# ============================================================================

class VulnerabilityLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class Vulnerability:
    """Represents identified vulnerability"""
    location: str
    issue: str
    level: VulnerabilityLevel
    recommendation: str
    cwe_id: Optional[str] = None


class SecurityAgent:
    """Custom Security Agent Mode for code review and compliance"""
    
    @staticmethod
    def review_for_vulnerabilities(code: str) -> List[Vulnerability]:
        """Review code for security vulnerabilities"""
        
        vulnerabilities = []
        
        # Check for SQL injection
        if "SQL = " in code or "ExecuteNonQuery" in code:
            vulnerabilities.append(Vulnerability(
                location="Database query",
                issue="Potential SQL injection vulnerability",
                level=VulnerabilityLevel.HIGH,
                recommendation="Use parameterized queries: "
                              "@param = @value in ExecuteNonQuery",
                cwe_id="CWE-89"
            ))
        
        # Check for hardcoded credentials
        if "password" in code.lower() and "=" in code:
            vulnerabilities.append(Vulnerability(
                location="Configuration",
                issue="Hardcoded credentials detected",
                level=VulnerabilityLevel.CRITICAL,
                recommendation="Use environment variables or Azure Key Vault "
                              "for sensitive data",
                cwe_id="CWE-798"
            ))
        
        # Check for weak cryptography
        if "MD5" in code or "SHA1" in code:
            vulnerabilities.append(Vulnerability(
                location="Cryptography",
                issue="Weak hashing algorithm detected",
                level=VulnerabilityLevel.HIGH,
                recommendation="Use SHA-256 or better for security operations",
                cwe_id="CWE-327"
            ))
        
        return vulnerabilities
    
    @staticmethod
    def check_gdpr_compliance(code: str) -> Dict[str, any]:
        """Check for GDPR compliance patterns"""
        
        compliance_report = {
            "data_retention": False,
            "consent_handling": False,
            "encryption": False,
            "audit_logging": False,
            "vulnerabilities": []
        }
        
        if "delete" in code.lower() and "retention" in code.lower():
            compliance_report["data_retention"] = True
        
        if "consent" in code.lower():
            compliance_report["consent_handling"] = True
        
        if "encrypt" in code.lower() or "hash" in code.lower():
            compliance_report["encryption"] = True
        
        if "log" in code.lower() or "audit" in code.lower():
            compliance_report["audit_logging"] = True
        
        if not compliance_report["encryption"]:
            compliance_report["vulnerabilities"].append(
                "No encryption detected for sensitive data"
            )
        
        return compliance_report


# ============================================================================
# DEMONSTRATION
# ============================================================================

if __name__ == "__main__":
    print("=" * 70)
    print("GitHub Copilot Custom Agent Modes Demonstration")
    print("=" * 70)
    
    # -------- DEVOPS AGENT --------
    print("\n" + "=" * 70)
    print("1. DevOps Agent Mode - Infrastructure as Code")
    print("=" * 70)
    
    app_config = AppServiceConfig(
        name="myapp",
        resource_group="myresourcegroup",
        region="eastus",
        tier=AppServiceTier.STANDARD,
        instance_count=2,
        runtime="v6.0"
    )
    
    print("\nGenerated Terraform Configuration:")
    print(app_config.to_terraform())
    
    pipeline = DevOpsAgent.generate_ci_cd_pipeline("MyApp", "dotnet")
    print("\nGenerated CI/CD Pipeline (YAML structure):")
    print(json.dumps(pipeline, indent=2))
    
    dockerfile = DevOpsAgent.generate_docker_config("MyApp", "dotnet")
    print("\nGenerated Dockerfile:")
    print(dockerfile)
    
    # -------- DATABASE AGENT --------
    print("\n" + "=" * 70)
    print("2. Database Agent Mode - Query Optimization")
    print("=" * 70)
    
    query = "SELECT * FROM Users u JOIN Orders o ON u.id = o.user_id"
    optimization = DatabaseAgent.analyze_and_optimize_query(query)
    
    print(f"\nOriginal Query:\n{optimization.original_query}")
    print(f"\nOptimized Query:\n{optimization.optimized_query}")
    print(f"\nExpected Improvement: {optimization.expected_improvement}")
    print(f"Rationale: {optimization.rationale}")
    
    # Schema design
    entities = {
        "Users": ["name", "email", "phone"],
        "Orders": ["user_id", "amount", "status"],
        "Products": ["name", "price", "inventory"]
    }
    
    schema = DatabaseAgent.design_normalized_schema(entities)
    print("\nGenerated Normalized Schema:")
    print(schema)
    
    # -------- SECURITY AGENT --------
    print("\n" + "=" * 70)
    print("3. Security Agent Mode - Vulnerability Analysis")
    print("=" * 70)
    
    vulnerable_code = """
    string SQL = "SELECT * FROM Users WHERE id = " + userId;
    string password = "Admin123!";
    using (SqlCommand cmd = new SqlCommand(SQL, conn))
    {
        cmd.ExecuteNonQuery();
    }
    string hash = MD5.Create().ComputeHash(data);
    """
    
    vulnerabilities = SecurityAgent.review_for_vulnerabilities(vulnerable_code)
    print("\nSecurity Review Results:")
    for vuln in vulnerabilities:
        print(f"\n  [{vuln.level.value.upper()}] {vuln.issue}")
        print(f"  Location: {vuln.location}")
        print(f"  CWE: {vuln.cwe_id}")
        print(f"  Recommendation: {vuln.recommendation}")
    
    # GDPR Compliance check
    compliant_code = """
    void DeleteUserData(int userId)
    {
        // Check user consent
        if (!userConsent.IsGranted) return;
        
        // Log audit trail
        auditLog.Log($"Deleting user {userId}");
        
        // Encrypt data
        byte[] encrypted = EncryptUserData(userData);
        
        // Apply retention policy
        if (DateTime.Now > lastAccessDate.AddDays(365))
        {
            database.DeleteUser(userId);
        }
    }
    """
    
    compliance = SecurityAgent.check_gdpr_compliance(compliant_code)
    print("\n\nGDPR Compliance Check:")
    print(json.dumps(compliance, indent=2))
    
    print("\n" + "=" * 70)
    print("Demonstration Complete!")
    print("=" * 70)
